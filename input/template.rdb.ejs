@@@FILE:[test/databasify.sql]@@@
<% // javascript

const codifyOptions = codifier.DatabaseCodifyOptions
const databaseOptions = databasifier.SqlServerDatabaseOptions
const tagPrefixes = ['domain','transition','bitemporal']
const dbJson = databasifier.getDatabaseJson(project, codifyOptions, databaseOptions, tagPrefixes)

dbJson.tables.forEach(table => {

  const domain = codifier.codifyText(table.domain, codifyOptions, true)
  const bitemporal = (table.bitemporal === "true")
  const transition = (table.transition === "true")

%>
/* ###################################################### */

CREATE TABLE dbo.[<%- domain ? domain.concat("_") : null %><%- table.baseName %>] (
  [<%- domain ? domain.concat("_") : null %><%- table.baseName %>_PK] BIGINT IDENTITY(1,1) NOT NULL,
  [<%- domain ? domain.concat("_") : null %><%- table.baseName %>_NK] [varchar](200) NOT NULL,
  [<%- domain ? domain.concat("_") : null %><%- table.baseName %>_FK] [varchar](200) NOT NULL,
<% // javascript

  applyColumnSort(table.columns) // see function at end of script
  table.columns.forEach((column, columnIndex) => {

%><%- columnIndex > 0 ? "," : " " 
%><%- " ".concat(column.name) 
%><%- " ".concat(column.dataType) 
%><%- column.required ? " NOT NULL" : null %>
<% // javascript
  
  })

  const pkColumns = table.columns.filter(c => c.primary === true).map(c => c.name) ?? []
  const grainColumns = table.columns.filter(c => c.grain === true && !(c.primary === true)).map(c => c.name) ?? []

%>,[BUSINESS_EFFECTIVE_BEGIN_DATETIME] [DATETIME2](7) NULL,
[BUSINESS_EFFECTIVE_END_DATETIME] [DATETIME2](7) NULL,
[RECORD_VALID_BEGIN_DATETIME] [DATETIME2](7) NULL,
[RECORD_VALID_END_DATETIME] [DATETIME2](7) NULL,
[ENTERED_DATETIME] [DATETIME2](7) NULL,
[UPDATED_DATETIME] [DATETIME2](7) NULL,
[BATCH_ID] [VARCHAR](200) NULL,
[INVALIDATED_BATCH_ID] [VARCHAR](200) NULL,
[INTRA_BATCH_LOOP_SEQUENCE] [INT] NULL,
[GENERATED_RECORD_IND] [INT] NULL,
[CHANGE_HASH] [BINARY](32) NULL,
[SOURCE_SYSTEM_CODE] [VARCHAR](100) NULL
<%- // javascript
  pkColumns.length > 0 ?  ` 

  CONSTRAINT [${domain ? domain.concat("_") : null}${table.baseName}_PK] PRIMARY KEY CLUSTERED 
   ( 
   ${ pkColumns.join(",") } ASC )
  WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY] 
  \n` : null
%>;
<% // javascript
  if(grainColumns.length > 0) {
%>
CREATE UNIQUE INDEX UX_<%- table.baseName -%>_GRAIN ON [<%- domain ? domain.concat("_") : null %><%= table.baseName %>] (
  <%- grainColumns.join(",") %>
);
<% // javascript
  }
})

function applyColumnSort(columns) {
  columns.sort((a, b) => {
    let sortValue
    // 1. primary
    sortValue = (b.primary === true ? 1 : 0)- (a.primary === true ? 1 : 0)
    if(sortValue !== 0) return sortValue

    // 2. grain
    sortValue = (b.grain === true ? 1 : 0) - (a.grain === true ? 1 : 0)
    if(sortValue !== 0) return sortValue

    // 3. fks
    sortValue = (!!b.attributeClass?.entityId ? 1 : 0) - (!!a.attributeClass?.entityId ? 1 : 0)
    if(sortValue !== 0) return sortValue

    // 4. alpha
    return a.name.localeCompare(b.name)
  })

}
%>